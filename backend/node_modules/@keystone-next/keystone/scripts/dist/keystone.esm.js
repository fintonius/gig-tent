import path from 'path';
import meow from 'meow';
import express from 'express';
import { createAdminUIServer, generateAdminUI, buildAdminUI } from '@keystone-next/admin-ui/system';
import { i as initConfig, c as createSystem, a as createKeystone } from '../../dist/initConfig-dabb96ab.esm.js';
import { addHook } from 'pirates';
import { transformSync } from '@babel/core';
import sourceMapSupport from 'source-map-support';
import cors from 'cors';
import { ApolloServer } from 'apollo-server-express';
import { graphqlUploadExpress } from 'graphql-upload';
import { formatError } from '@keystonejs/keystone/lib/Keystone/format-error';
import { implementSession } from '../../session/dist/keystone.esm.js';
import { parse, GraphQLScalarType, printSchema } from 'graphql';
import { outputFile, existsSync } from 'fs-extra';
import prettier from 'prettier';
import '@babel/runtime/helpers/objectSpread2';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@graphql-tools/merge';
import '@graphql-tools/utils';
import '@graphql-tools/schema';
import '../../dist/schema-15c288ef.esm.js';
import '@keystonejs/server-side-graphql-client';
import 'graphql/execution/values';
import '@keystonejs/keystone';
import '@keystonejs/adapter-mongoose';
import '@keystonejs/adapter-knex';
import '@keystonejs/adapter-prisma';
import '@keystone-next/fields';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';

/*
This is a slightly-modified version of preconstruct's hook for use with
keystone project files in the monorepo. Importantly it doesn't accept a cwd and
sets rootMode: "upward-optional"
*/
const EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const babelPlugins = [require.resolve('@babel/plugin-transform-modules-commonjs')];
const hook = () => {
  let compiling = false;
  let sourceMaps = {};
  let needsToInstallSourceMapSupport = true;

  function compileHook(code, filename) {
    if (compiling) return code; // we do this lazily because jest has its own require implementation
    // which means preconstruct's require hook won't be run
    // so we don't want to install source map support because that will mess up
    // jest's source map support

    if (needsToInstallSourceMapSupport) {
      sourceMapSupport.install({
        environment: 'node',

        retrieveSourceMap(source) {
          let map = sourceMaps[source];

          if (map !== undefined) {
            return {
              url: source,
              map
            };
          } else {
            return null;
          }
        }

      });
      needsToInstallSourceMapSupport = false;
    }

    try {
      compiling = true;
      let output = transformSync(code, {
        plugins: babelPlugins,
        filename,
        sourceMaps: 'both',
        rootMode: 'upward-optional'
      });
      sourceMaps[filename] = output.map;
      return output.code;
    } finally {
      compiling = false;
    }
  }

  return addHook(compileHook, {
    exts: EXTENSIONS
  });
};
const requireSource = filePath => {
  const unregister = hook();

  const result = require(filePath);

  unregister();
  return result;
};

const addApolloServer = ({
  server,
  graphQLSchema,
  createContext,
  sessionImplementation
}) => {
  const apolloServer = new ApolloServer({
    uploads: false,
    schema: graphQLSchema,
    // FIXME: allow the dev to control where/when they get a playground
    playground: {
      settings: {
        'request.credentials': 'same-origin'
      }
    },
    formatError,
    // TODO: this needs to be discussed
    context: async ({
      req,
      res
    }) => createContext({
      sessionContext: await (sessionImplementation === null || sessionImplementation === void 0 ? void 0 : sessionImplementation.createSessionContext(req, res, createContext)),
      req
    }) // FIXME: support for apollo studio tracing
    // ...(process.env.ENGINE_API_KEY || process.env.APOLLO_KEY
    //   ? { tracing: true }
    //   : {
    //       engine: false,
    //       // Only enable tracing in dev mode so we can get local debug info, but
    //       // don't bother returning that info on prod when the `engine` is
    //       // disabled.
    //       tracing: dev,
    //     }),
    // FIXME: Support for generic custom apollo configuration
    // ...apolloConfig,

  }); // FIXME: Support custom API path via config.graphql.path.
  // Note: Core keystone uses '/admin/api' as the default.
  // FIXME: Support for file handling configuration
  // maxFileSize: 200 * 1024 * 1024,
  // maxFiles: 5,

  server.use(graphqlUploadExpress());
  apolloServer.applyMiddleware({
    app: server,
    path: '/api/graphql',
    cors: false
  });
};

const createExpressServer = async (config, graphQLSchema, createContext, dev, projectAdminPath) => {
  var _config$server;

  const server = express();

  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.cors) {
    // Setting config.server.cors = true will provide backwards compatible defaults
    // Otherwise, the user can provide their own config object to use
    const corsConfig = typeof config.server.cors === 'boolean' ? {
      origin: true,
      credentials: true
    } : config.server.cors;
    server.use(cors(corsConfig));
  }

  const sessionImplementation = config.session ? implementSession(config.session()) : undefined;
  console.log('âœ¨ Preparing GraphQL Server');
  addApolloServer({
    server,
    graphQLSchema,
    createContext,
    sessionImplementation
  });
  console.log('âœ¨ Preparing Next.js app');
  server.use(await createAdminUIServer(config.ui, createContext, dev, projectAdminPath, sessionImplementation));
  return server;
};

let printEnumTypeDefinition = node => {
  return `export type ${node.name.value} =\n${node.values.map(x => `  | ${JSON.stringify(x.name.value)}`).join('\n')};`;
};

function printInputTypesFromSchema(schema, schemaObj, scalars) {
  let ast = parse(schema);

  let printTypeNodeWithoutNullable = node => {
    if (node.kind === 'ListType') {
      return `ReadonlyArray<${printTypeNode(node.type)}>`;
    }

    let name = node.name.value;

    if (schemaObj.getType(name) instanceof GraphQLScalarType) {
      if (scalars[name] === undefined) {
        return 'any';
      }

      return `Scalars[${JSON.stringify(name)}]`;
    }

    return name;
  };

  let printTypeNode = node => {
    if (node.kind === 'NonNullType') {
      return printTypeNodeWithoutNullable(node.type);
    }

    return `${printTypeNodeWithoutNullable(node)} | null`;
  };

  let printInputObjectTypeDefinition = node => {
    var _node$fields;

    let str = `export type ${node.name.value} = {\n`;
    (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.forEach(node => {
      str += `  readonly ${node.name.value}${node.type.kind === 'NonNullType' || node.defaultValue ? '' : '?'}: ${printTypeNode(node.type)};\n`;
    });
    str += '};';
    return str;
  };

  let typeString = 'type Scalars = {\n';

  for (let scalar in scalars) {
    typeString += `  readonly ${scalar}: ${scalars[scalar]};\n`;
  }

  typeString += '};';

  for (const node of ast.definitions) {
    if (node.kind === 'InputObjectTypeDefinition') {
      typeString += '\n\n' + printInputObjectTypeDefinition(node);
    }

    if (node.kind === 'EnumTypeDefinition') {
      typeString += '\n\n' + printEnumTypeDefinition(node);
    }
  }

  return {
    printedTypes: typeString + '\n',
    ast,
    printTypeNode
  };
}

function printGeneratedTypes(printedSchema, keystone, graphQLSchema) {
  let scalars = {
    ID: 'string',
    Boolean: 'boolean',
    String: 'string',
    Int: 'number',
    Float: 'number',
    JSON: 'import("@keystone-next/types").JSONValue'
  };
  let {
    printedTypes,
    ast,
    printTypeNode
  } = printInputTypesFromSchema(printedSchema, graphQLSchema, scalars);
  printedTypes += '\n';
  let allListsStr = '\nexport type KeystoneListsTypeInfo = {';
  let queryTypeName = graphQLSchema.getQueryType().name;
  let queryNode = ast.definitions.find(node => {
    return node.kind === 'ObjectTypeDefinition' && node.name.value === queryTypeName;
  });

  if (!queryNode) {
    throw new Error('Query type on GraphQL schema not found when generating types');
  }

  let queryNodeFieldsByName = {};

  for (const field of queryNode.fields) {
    queryNodeFieldsByName[field.name.value] = field;
  }

  let printArgs = args => {
    let types = '{\n';

    for (const arg of args) {
      if (arg.name.value === 'search' || arg.name.value === 'orderBy') continue;
      types += `  readonly ${arg.name.value}${arg.type.kind === 'NonNullType' || arg.defaultValue ? '' : '?'}: ${printTypeNode(arg.type)};\n`;
    }

    return types + '}';
  };

  for (const listKey in keystone.lists) {
    const list = keystone.lists[listKey];
    let backingTypes = '{\n';

    for (const field of list.fields) {
      for (const [key, {
        optional,
        type
      }] of Object.entries(field.getBackingTypes())) {
        backingTypes += `readonly ${JSON.stringify(key)}${optional ? '?' : ''}: ${type};\n`;
      }
    }

    backingTypes += '}';
    const {
      gqlNames
    } = list;
    let listTypeInfoName = `${listKey}ListTypeInfo`;
    printedTypes += `
export type ${listTypeInfoName} = {
  key: ${JSON.stringify(listKey)};
  fields: ${Object.keys(list.fieldsByPath).map(x => JSON.stringify(x)).join('|')}
  backing: ${backingTypes};
  inputs: {
    where: ${gqlNames.whereInputName};
    create: ${gqlNames.createInputName};
    update: ${gqlNames.updateInputName};
  };
  args: {
    listQuery: ${printArgs(queryNodeFieldsByName[gqlNames.listQueryName].arguments)}
  };
};

export type ${listKey}ListFn = (
  listConfig: import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>
) => import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>;
`;
    allListsStr += `\n  readonly ${JSON.stringify(listKey)}: ${listTypeInfoName};`;
  }

  return prettier.format(printedTypes + allListsStr + '\n};\n', {
    parser: 'babel-ts',
    trailingComma: 'es5',
    singleQuote: true
  });
}

async function saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath) {
  const printedSchema = printSchema(graphQLSchema);
  await outputFile(path.join(dotKeystonePath, 'schema.graphql'), printedSchema);
  await outputFile(path.join(dotKeystonePath, 'schema-types.ts'), printGeneratedTypes(printedSchema, keystone, graphQLSchema));
}

const CONFIG_PATH = path.join(process.cwd(), 'keystone');

// TODO: Don't generate or start an Admin UI if it isn't configured!!
const devLoadingHTMLFilepath = path.join(path.dirname(require.resolve('@keystone-next/keystone/package.json')), 'src', 'static', 'dev-loading.html');
const dev = async ({
  dotKeystonePath,
  projectAdminPath
}, script = 'dev') => {
  var _config$server;

  console.log('ðŸ¤ž Starting Keystone');
  const server = express();
  let expressServer = null;
  const config = initConfig(requireSource(CONFIG_PATH).default);

  const initKeystone = async () => {
    const {
      keystone,
      graphQLSchema,
      createContext
    } = createSystem(config, dotKeystonePath, script);
    console.log('âœ¨ Generating graphQL schema');
    await saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath);
    console.log('âœ¨ Connecting to the database');
    await keystone.connect({
      context: createContext({
        skipAccessControl: true
      })
    });
    console.log('âœ¨ Generating Admin UI code');
    await generateAdminUI(config, graphQLSchema, keystone, projectAdminPath);
    console.log('âœ¨ Creating server');
    expressServer = await createExpressServer(config, graphQLSchema, createContext, true, projectAdminPath);
    console.log(`ðŸ‘‹ Admin UI and graphQL API ready`);
  };

  server.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: expressServer ? true : false
    });
  });
  server.use((req, res, next) => {
    if (expressServer) return expressServer(req, res, next);
    res.sendFile(devLoadingHTMLFilepath);
  });
  const port = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.port) || process.env.PORT || 3000;
  server.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Dev Server Ready on http://localhost:${port}`); // Don't start initialising Keystone until the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().catch(err => {
      console.error(`ðŸš¨ There was an error initialising Keystone`);
      console.error(err);
      process.exit(1);
    });
  });
};

const prototype = async staticPaths => dev(staticPaths, 'prototype');

const start = async ({
  dotKeystonePath,
  projectAdminPath
}) => {
  var _config$server;

  console.log('ðŸ¤ž Starting Keystone');
  const apiFile = path.join(projectAdminPath, '.next/server/pages/api/__keystone_api_build.js');

  if (!existsSync(apiFile)) {
    throw new Error('keystone-next build must be run before running keystone-next start');
  }

  const config = initConfig(require(apiFile).config);
  const {
    keystone,
    graphQLSchema,
    createContext
  } = createSystem(config, dotKeystonePath, 'start');
  console.log('âœ¨ Connecting to the database');
  await keystone.connect({
    context: createContext({
      skipAccessControl: true
    })
  });
  console.log('âœ¨ Creating server');
  const server = await createExpressServer(config, graphQLSchema, createContext, false, projectAdminPath);
  console.log(`ðŸ‘‹ Admin UI and graphQL API ready`);
  const port = ((_config$server = config.server) === null || _config$server === void 0 ? void 0 : _config$server.port) || process.env.PORT || 3000;
  server.listen(port, err => {
    if (err) throw err;
    console.log(`â­ï¸ Server Ready on http://localhost:${port}`);
  });
};

async function build({
  dotKeystonePath,
  projectAdminPath
}) {
  console.log('ðŸ¤ž Building Keystone');
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const {
    keystone,
    graphQLSchema
  } = createSystem(config, dotKeystonePath, 'build');
  console.log('âœ¨ Generating graphQL schema');
  await saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath);
  console.log('âœ¨ Generating Admin UI code');
  await generateAdminUI(config, graphQLSchema, keystone, projectAdminPath);
  console.log('âœ¨ Building Admin UI');
  await buildAdminUI(projectAdminPath);
  console.log('âœ¨ Generating database client'); // FIXME: This should never generate a migratration... right?
  // FIXME: This needs to generate clients for the correct build target using binaryTarget
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#binarytargets-options

  if (keystone.adapter.name === 'prisma') {
    await keystone.adapter._generateClient(keystone._consolidateRelationships());
  }
}

const deploy = async ({
  dotKeystonePath
}) => {
  console.log('ðŸ¤ž Migrating Keystone');
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const keystone = createKeystone(config, dotKeystonePath, 'deploy');
  console.log('âœ¨ Deploying migrations');
  await keystone.adapter.deploy(keystone._consolidateRelationships());
};

const generate = async ({
  dotKeystonePath
}) => {
  console.log('ðŸ¤ž Migrating Keystone');
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const {
    keystone,
    graphQLSchema,
    createContext
  } = createSystem(config, dotKeystonePath, 'generate');
  console.log('âœ¨ Generating graphQL schema');
  await saveSchemaAndTypes(graphQLSchema, keystone, dotKeystonePath);
  console.log('âœ¨ Generating migration');
  await keystone.connect({
    context: createContext({
      skipAccessControl: true
    })
  });
  await keystone.disconnect();
};

function cli() {
  const commands = {
    prototype,
    dev,
    start,
    build,
    deploy,
    generate
  };
  const {
    input,
    help
  } = meow(`
    Usage
      $ keystone-next [command]
    Commands
      Run
        prototype     (default) start the project in prototyping mode
        dev           start the project in development mode
        start         start the project in production mode
      Build
        build         build the project (must be done before using start)
      Migrate (Prisma only)
        reset         reset the database (this will drop all data!)
        generate      generate a migration
        deploy        deploy all migrations
    `);
  const command = input[0] || 'prototype';

  if (!(command in commands)) {
    console.log(`${command} is not a command that keystone-next accepts`);
    console.log(help);
    process.exit(1);
  } // These paths are non-configurable, as we need to use them
  // to find the config file (for `start`) itself!


  const dotKeystonePath = path.resolve('.keystone');
  const projectAdminPath = path.join(dotKeystonePath, 'admin');
  const staticPaths = {
    dotKeystonePath,
    projectAdminPath
  };
  commands[command](staticPaths);
}

cli();
