'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@babel/runtime/helpers/objectWithoutProperties');
var objectSpread2 = require('../../../dist/objectSpread2-a7e51403.cjs.dev.js');
var slate = require('slate');
var core = require('@emotion/core');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var React = require('react');
var theme = require('@arch-ui/theme');
var _extends = require('@babel/runtime/helpers/extends');
var slateReact = require('slate-react');
var isHotkey = require('is-hotkey');
var views_editor_blocks_paragraph_dist_fieldsContent = require('../../editor/blocks/paragraph/dist/fields-content.cjs.dev.js');
var octiconsReact = require('@primer/octicons-react');
var index = require('../../../dist/index-004aa3eb.cjs.dev.js');
var reactDom = require('react-dom');
var reactPopper = require('react-popper');
require('@arch-ui/color-utils');
require('@arch-ui/tooltip');
require('@arch-ui/typography');
var toolbarComponents = require('../../../dist/toolbar-components-5704db01.cjs.dev.js');
var hooks = require('@arch-ui/hooks');
var utils = require('../../../dist/utils-5bfe488b.cjs.dev.js');
var applyRef = require('apply-ref');
var fields = require('@arch-ui/fields');
var input = require('@arch-ui/input');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefault(_defineProperty);
var React__default = /*#__PURE__*/_interopDefault(React);
var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var isHotkey__default = /*#__PURE__*/_interopDefault(isHotkey);
var applyRef__default = /*#__PURE__*/_interopDefault(applyRef);

function markPlugin(type, options) {
  return {
    onKeyDown(event, editor, next) {
      // If it doesn't match our `key`, let other plugins handle it.
      if (!options.test(event)) return next(); // Prevent the default characters from being inserted.

      event.preventDefault(); // Toggle the mark `type`.

      editor.toggleMark(type);
    },

    renderMark: (props, editor, next) => {
      if (props.mark.type === type) {
        return options.render(props);
      }

      return next();
    }
  };
}

let marks = {
  bold: {
    test: isHotkey__default['default']('mod+b'),
    label: 'Bold',
    icon: props => {
      return /*#__PURE__*/React__default['default'].createElement("strong", _extends__default['default']({}, props, {
        "aria-hidden": true
      }), "B");
    },
    render: props => /*#__PURE__*/React__default['default'].createElement("strong", props.attributes, props.children)
  },
  italic: {
    test: isHotkey__default['default']('mod+i'),
    label: 'Italic',
    icon: props => {
      return /*#__PURE__*/React__default['default'].createElement("em", _extends__default['default']({}, props, {
        "aria-hidden": true
      }), "I");
    },
    render: props => /*#__PURE__*/React__default['default'].createElement("em", props.attributes, props.children)
  },
  strikethrough: {
    test: isHotkey__default['default']('mod+~'),
    label: 'Strikethrough',
    icon: props => {
      return /*#__PURE__*/React__default['default'].createElement("s", _extends__default['default']({}, props, {
        "aria-hidden": true
      }), "S");
    },
    render: props => /*#__PURE__*/React__default['default'].createElement("s", props.attributes, props.children)
  },
  underline: {
    test: isHotkey__default['default']('mod+u'),
    label: 'Underline',
    icon: props => {
      return /*#__PURE__*/React__default['default'].createElement("u", _extends__default['default']({}, props, {
        "aria-hidden": true
      }), "U");
    },
    render: props => /*#__PURE__*/React__default['default'].createElement("u", props.attributes, props.children)
  }
};
let markTypes = Object.keys(marks);
let plugins = Object.entries(marks).map(([type, options]) => {
  return markPlugin(type, options);
});

/** @jsx jsx */

const getSelectedElement = () => {
  if (document.selection) return document.selection.createRange().parentElement();else {
    var selection = window.getSelection();
    if (selection.rangeCount > 0) return selection.getRangeAt(0).startContainer.parentNode;
  }
};

let AddBlock = ({
  editorState,
  editor,
  blocks
}) => {
  let [isOpen, setIsOpen] = React.useState(false);
  let focusBlock = editorState.focusBlock;
  let iconRef = React.useRef(null);
  let menuRef = React.useRef(null);
  let layout = React.useCallback(() => {
    let iconEle = iconRef.current;
    let menuEle = menuRef.current;
    const elm = getSelectedElement();

    if (focusBlock === null || focusBlock.text !== '' || focusBlock.type !== views_editor_blocks_paragraph_dist_fieldsContent.type) {
      iconEle.style.top = `-9999px`;
      iconEle.style.left = `-9999px`;
      menuEle.style.top = `-9999px`;
      menuEle.style.left = `-9999px`;

      if (isOpen) {
        setIsOpen(false);
      }

      return;
    }

    if (!blocks || !Object.keys(blocks).length) return;

    if (elm && editor && editor.el.contains(elm)) {
      iconEle.style.top = `${elm.offsetTop + elm.offsetHeight / 2}px`;
      iconEle.style.left = 0;
      menuEle.style.top = `${elm.offsetTop - elm.offsetHeight / 2}px`;
      menuEle.style.left = `42px`;
    } else {
      if (isOpen) {
        setIsOpen(false);
      }
    }
  }, [focusBlock, iconRef.current, menuRef.current]);
  React.useLayoutEffect(layout);
  return core.jsx(React.Fragment, null, core.jsx("div", {
    css: {
      position: 'absolute',
      zIndex: 10,
      transform: 'translate(0, -50%)',
      top: -99999,
      left: -9999
    },
    ref: iconRef
  }, core.jsx("button", {
    type: "button",
    css: {
      border: 'none',
      background: '#efefef',
      color: '#aaa',
      width: 24,
      height: 24,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      marginLeft: 4,
      ':hover': {
        color: '#888'
      }
    },
    onClick: () => {
      setIsOpen(x => !x);
    },
    title: "Add block"
  }, core.jsx(octiconsReact.PlusIcon, {
    css: {
      transition: '50ms transform',
      transform: isOpen ? 'rotateZ(45deg)' : 'rotateZ(0deg)'
    },
    title: isOpen ? 'Close' : 'Open'
  }))), core.jsx("div", {
    ref: menuRef,
    css: {
      position: 'absolute',
      zIndex: 10,
      top: -99999,
      left: -9999
    }
  }, isOpen && core.jsx("ul", {
    css: {
      background: 'white',
      listStyle: 'none',
      padding: 0,
      margin: 0,
      border: 'solid 1px #eaeaea'
    }
  }, core.jsx("li", {
    css: {
      display: 'flex',
      justifyContent: 'left',
      alignItems: 'center'
    }
  }, core.jsx("strong", {
    css: {
      textTransform: 'uppercase',
      color: '#999',
      fontSize: '.8rem',
      padding: '5px 15px'
    }
  }, "Insert Block")), Object.keys(blocks).map(key => {
    let {
      Sidebar
    } = blocks[key];

    if (!blocks[key].withChrome || Sidebar === undefined) {
      return null;
    }

    return core.jsx("li", {
      key: `sidebar-${key}`,
      css: {
        display: 'flex',
        justifyContent: 'left',
        alignItems: 'center'
      }
    }, core.jsx(Sidebar, {
      key: key,
      editor: editor,
      blocks: blocks
    }));
  }))));
};

let stopPropagation = e => {
  e.stopPropagation();
};

function InnerToolbar({
  blocks,
  editor,
  editorState
}) {
  return core.jsx("div", {
    css: {
      display: 'flex'
    }
  }, Object.keys(blocks).map(x => blocks[x].withChrome && blocks[x].Toolbar).filter(x => x).reduce((children, Toolbar) => {
    return core.jsx(Toolbar, {
      editor: editor,
      editorState: editorState
    }, children);
  }, core.jsx(React.Fragment, null, Object.keys(marks).map(name => {
    let Icon = marks[name].icon;
    return core.jsx(toolbarComponents.ToolbarButton, {
      label: marks[name].label,
      icon: core.jsx(Icon, null),
      isActive: editorState.activeMarks.some(mark => mark.type === name),
      onClick: () => {
        editor.toggleMark(name);
        editor.focus();
      },
      key: name
    });
  }), core.jsx(toolbarComponents.ToolbarButton, {
    label: "Remove Formatting",
    icon: core.jsx(octiconsReact.CircleSlashIcon, null),
    onClick: () => {
      markTypes.forEach(mark => {
        editor.removeMark(mark);
      });
      editor.focus();
    }
  }), Object.keys(blocks).map(type => {
    let ToolbarElement = blocks[type].ToolbarElement;

    if (!blocks[type].withChrome || ToolbarElement === undefined) {
      return null;
    }

    return core.jsx(ToolbarElement, {
      key: type,
      editor: editor,
      editorState: editorState
    });
  }))));
}

const PopperRender = /*#__PURE__*/React.forwardRef(({
  update,
  editorState,
  style,
  children
}, ref) => {
  let {
    fragment
  } = editorState;
  let shouldShowToolbar = fragment.text !== '';
  let containerRef = React.useRef(null);
  let snapshot = hooks.useMeasure(containerRef);
  React.useLayoutEffect(() => {
    if (shouldShowToolbar) {
      update();
    }
  }, [update, editorState, snapshot, shouldShowToolbar]);
  return /*#__PURE__*/reactDom.createPortal(core.jsx("div", {
    onMouseDown: stopPropagation,
    ref: node => {
      applyRef__default['default'](ref, node);
      applyRef__default['default'](containerRef, node);
    },
    style: style,
    css: {
      // this isn't as nice of a transition as i'd like since the time is fixed
      // i think it would better if it was physics based but that would probably
      // be a lot of work for little gain
      // maybe base the transition time on the previous value?
      transition: 'transform 100ms, opacity 100ms'
    }
  }, core.jsx("div", {
    css: {
      backgroundColor: theme.colors.N90,
      padding: 8,
      borderRadius: 6,
      margin: theme.gridSize,
      display: shouldShowToolbar ? 'flex' : 'none'
    }
  }, shouldShowToolbar && children)), document.body);
});
var Toolbar = (({
  editorState,
  blocks,
  editor
}) => {
  // this element is created here so that when the popper rerenders
  // the inner toolbar won't have to update
  const children = core.jsx(InnerToolbar, {
    blocks: blocks,
    editor: editor,
    editorState: editorState
  }); // the reason we do this rather than having the selection reference
  // be constant is because the selection reference
  // has some internal state and it shouldn't persist between different
  // editor references

  const virtualElement = React.useMemo(utils.getSelectionReference, []);
  const [popperElement, setPopperElement] = React.useState(null);
  const {
    styles,
    update
  } = reactPopper.usePopper(virtualElement, popperElement, {
    placement: 'top',
    modifiers: [{
      name: 'computeStyles',
      options: {
        adaptive: false
      }
    }]
  });
  return core.jsx(PopperRender, {
    update,
    editorState,
    style: objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, styles.popper), {}, {
      zIndex: 10
    }),
    blocks,
    editor,
    ref: setPopperElement,
    children
  });
});

function getSchema(blocks) {
  const schema = {
    document: {
      last: {
        type: views_editor_blocks_paragraph_dist_fieldsContent.type
      },
      normalize: (editor, {
        code,
        node
      }) => {
        switch (code) {
          case 'last_child_type_invalid':
            {
              const paragraph = slate.Block.create(views_editor_blocks_paragraph_dist_fieldsContent.type);
              return editor.insertNodeByKey(node.key, node.nodes.size, paragraph);
            }
        }
      }
    },
    blocks: {}
  };
  Object.keys(blocks).forEach(type => {
    if (typeof blocks[type].getSchema === 'function') {
      schema.blocks[type] = blocks[type].getSchema({
        blocks
      });
    }
  });
  return schema;
}

function Stories({
  value: editorState,
  onChange,
  blocks,
  className,
  id,
  isDisabled
}) {
  let schema = React.useMemo(() => {
    return getSchema(blocks);
  }, [blocks]);
  let plugins$1 = React.useMemo(() => {
    const renderNode = props => {
      let block = blocks[props.node.type];

      if (block) {
        return core.jsx(block.Node, _extends__default['default']({}, props, {
          blocks: blocks
        }));
      }

      return null;
    };

    return Object.values(blocks).reduce((combinedPlugins, block) => {
      if (typeof block.getPlugins !== 'function') {
        return combinedPlugins;
      }

      return [...combinedPlugins, ...block.getPlugins({
        blocks
      })];
    }, [...plugins, {
      renderBlock: renderNode,
      renderInline: renderNode
    }]);
  }, [blocks]);
  let [editor, setEditor] = index.useStateWithEqualityCheck(null);
  return core.jsx("div", {
    className: className,
    css: {
      position: 'relative'
    },
    id: id
  }, core.jsx(slateReact.Editor, {
    schema: schema,
    ref: setEditor,
    plugins: plugins$1,
    value: editorState,
    tabIndex: 0,
    onChange: ({
      value
    }) => {
      onChange(value);
    },
    readOnly: isDisabled,
    css: {
      minHeight: 200,
      padding: '16px 32px'
    }
  }), core.jsx(AddBlock, {
    editor: editor,
    editorState: editorState,
    blocks: blocks
  }), core.jsx(Toolbar, {
    editorState,
    editor,
    blocks
  }));
}

class ErrorBoundary extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty__default['default'](this, "state", {
      hasError: false
    });
  }

  static getDerivedStateFromError() {
    return {
      hasError: true
    };
  }

  render() {
    if (this.state.hasError) {
      return core.jsx("span", {
        css: {
          color: theme.colors.danger
        }
      }, "Unable to render content");
    }

    return this.props.children;
  }

}

let ContentField = ({
  field,
  value,
  onChange,
  autoFocus,
  errors,
  isDisabled
}) => {
  const htmlID = `ks-content-editor-${field.path}`;
  return core.jsx(fields.FieldContainer, null, core.jsx(fields.FieldLabel, {
    htmlFor: htmlID,
    field: field,
    errors: errors
  }), core.jsx(ErrorBoundary, null, Object.values(field.getBlocks()).filter(({
    Provider,
    options
  }) => Provider && options).reduce((children, {
    Provider,
    options
  }, index) => // Using index within key is ok here as the blocks never change
  // across renders
  core.jsx(Provider, {
    value: options,
    key: `${htmlID}-provider-${index}`
  }, children), core.jsx(Stories, {
    key: htmlID,
    blocks: field.getBlocks(),
    value: value,
    onChange: onChange,
    autoFocus: autoFocus,
    id: htmlID,
    css: objectSpread2._objectSpread2(objectSpread2._objectSpread2({}, input.inputStyles({
      isMultiline: true
    })), {}, {
      padding: '0'
    }),
    isDisabled: isDisabled
  }))));
};

exports.default = ContentField;
